#Introduction:
This project implements three popular priority queues namely Binary heap, 4 way cache optimized heap and pairing heap and generates Huffman trees using these three data structures. 
The best performance data structure is then selected for Huffman code program.  
The program has 4 phases –  
1. Generating Huffman tree using the data structure. 
1. Generating code table using Huffman tree. 
1. Encode the data using the input file and code table. 
1. Construct a decode tree using code table file and finally decode the data using the tree and encoded file. 


The program takes an input file and a frequency table is built over that input. 
The Huffman tree is used to build the code table which is encoded. 
The encoded message and the code table are then used by the decoder to decode the encoded message.
The output is then compared with the input file to check whether the decoded data is the same as input file. 


##Project structure
As per the run time analysis and observation 4 way-cache optimized heap provides better performance over other heaps. Therefore Huffman tree has been generated using this data structure. 
The frequency table has been built using a HashMap which store the frequencies and keys(input value) over the scanned input values. 
The HashMap has been mapped into an Array of Nodes which has been sent as input to the Huffman code program.   
The program contains the following classes and methods as described below -  
1. class FourWayCacheHeap – Methods included :  
   1.Node generate_huffman_tree_using_four_way_heap(Node[] Arr1) :  Method generates a Huffman node by calling build_min_heap(), remove_min() methods respectively and inserting the new node in the heap by calling min_heap_insert() method. 
   1.void build_min_heap(Node[] Arr1): Builds the min heap by calling heapify(Arr,i) method and passing the array to the method. 
   1.Node remove_min(Node[] Arr1) : Returns the top element of the min heap. 
   1.void min_heap_insert(Node[] Arr1, Node n):  Inserts the new min node into the min heap. 
   1.void code_table(HashMap<Integer, String> h, Node root, String s ): Generates the code by recursive calls and stores the key and the binary string in a hashmap. 
1. class encoder – Methods included 
   1.void writeCodeTable(Map<Integer, String>  codeTable): Uses the hashmap generated by the code_table() method and writes to a file named codeFileName. 
   1.void encodeData(List<Integer> encode, Map<Integer, String> codeTable ): Takes the input values list and the codeTable, converts the binary string accredited with each input value(key) into bytes and writes them into a new file Named encoded.bin. 
1.  class decoder – Methods includes 
   1.hnode buildCodeTable():Reads the codeFileName and constructs the decode tree. 
   1.void decodeValues(hnode root): Takes the decoded tree and encodedLarge.bin file and converts the codes into keys.  
1. class Node -  describes the node structure for the heap.  
1. class Huffman - Basically acts as an interface for calling the encoder methods and passing the code table to encoder class.


#To Run:
javac encoder.java decoder.java
java encoder.java input_file.txt
java decoder.java encoded.bin code_table.txt